summary_colors <- c(
block1 = "#e6f0ff",  # Light blue for "Call"
block2 = "#e6ffe6",  # Light green for "Residuals"
block3 = "#fff5e6",  # Light orange for "Coefficients"
block4 = "#f9e6ff"   # Light purple for "Model Fit"
)
#Helper functions
# FUNCTION A: Prints the full, 4-block summary with colors
summary_with_colors <- function(model) {
summary_text <- capture.output(summary(model))
call_start <- grep("^Call:", summary_text)
residuals_start <- grep("^Residuals:", summary_text)
coeffs_start <- grep("^Coefficients:", summary_text)
footer_start <- grep("^Residual standard error:", summary_text)
block1_text <- summary_text[call_start:(residuals_start - 1)]
block2_text <- summary_text[residuals_start:(coeffs_start - 1)]
block3_text <- summary_text[coeffs_start:(footer_start - 1)]
block4_text <- summary_text[footer_start:length(summary_text)]
wrap_in_div <- function(text, color) {
text_collapsed <- paste(text, collapse = "\n")
sprintf(
'<div style="background-color: %s; border: 1px solid #ddd; border-radius: 5px; padding: 10px; margin-bottom: 10px;"><pre style="margin: 0;">%s</pre></div>',
color,
htmltools::htmlEscape(text_collapsed)
)
}
html_output <- paste(
wrap_in_div(block1_text, summary_colors["block1"]),
wrap_in_div(block2_text, summary_colors["block2"]),
wrap_in_div(block3_text, summary_colors["block3"]),
wrap_in_div(block4_text, summary_colors["block4"]),
sep = "\n"
)
asis_output(html_output)
}
# FUNCTION B: Highlights inline text with a block's color
highlight_block_text <- function(text, block_number) {
color <- summary_colors[block_number]
sprintf(
'<span style="background-color: %s; padding: 2px 5px; border-radius: 4px; font-family: monospace;">%s</span>',
color,
text
)
}
# FUNCTION C: Prints a single, isolated block of the summary
print_summary_block <- function(model, block_number) {
if (!(block_number %in% 1:4)) {
stop("Invalid block_number. Please choose a number from 1 to 4.")
}
summary_text <- capture.output(summary(model))
call_start <- grep("^Call:", summary_text)
residuals_start <- grep("^Residuals:", summary_text)
coeffs_start <- grep("^Coefficients:", summary_text)
footer_start <- grep("^Residual standard error:", summary_text)
all_blocks <- list(
"1" = summary_text[call_start:(residuals_start - 1)],
"2" = summary_text[residuals_start:(coeffs_start - 1)],
"3" = summary_text[coeffs_start:(footer_start - 1)],
"4" = summary_text[footer_start:length(summary_text)]
)
selected_text <- all_blocks[[as.character(block_number)]]
selected_color <- summary_colors[block_number]
text_collapsed <- paste(selected_text, collapse = "\n")
html_output <- sprintf(
'<div style="background-color: %s; border: 1px solid #ddd; border-radius: 5px; padding: 10px;"><pre style="margin: 0;">%s</pre></div>',
selected_color,
htmltools::htmlEscape(text_collapsed)
)
asis_output(html_output)
}
summary_with_colors(model_total)
print(df.residual(model_total))
deviance(model_total)
deviance(model_total)/196
sqrt(deviance(model_total)/196)
model_null <- lm(sales ~ 1, data=data_adv)
anova(model_null,model_total)
print_summary_block(model_total, 3)
confint(model_total)
print_coeffs_with_ci <- function(model) {
s <- summary(model)
coeffs <- s$coefficients
cis <- confint(model)
get_stars <- function(p_value) {
if (p_value < 0.001) return("***")
if (p_value < 0.01)  return("**")
if (p_value < 0.05)  return("*")
if (p_value < 0.1)   return(".")
return(" ")
}
# Build the text output line-by-line
output_lines <- "Coefficients:"
# Note the extra space for the significance star column at the end
col_names <- sprintf("%-12s %10s %11s %8s %10s %10s %9s %s",
"", "Estimate", "Std. Error", "t value", "Pr(>|t|)", "2.5 %",
"97.5 % ", "")
output_lines <- c(output_lines, col_names)
# Create a formatted line for each coefficient
for (i in 1:nrow(coeffs)) {
row_name <- rownames(coeffs)[i]
line_data <- c(
# Predictor name, left-aligned
sprintf("%-12s", row_name),
# Coefficient values, right-aligned with specific decimal places
sprintf("%10.6f", coeffs[i, "Estimate"]),
sprintf("%11.6f", coeffs[i, "Std. Error"]),
sprintf("%8.3f",  coeffs[i, "t value"]),
# P-value, using scientific notation if small, or fixed if larger
sprintf("%10s", format.pval(coeffs[i, "Pr(>|t|)"], digits = 2)),
# Confidence Intervals
sprintf("%10.4f", cis[i, 1]), # Lower bound
sprintf("%9.4f", cis[i, 2]),  # Upper bound
# Significance stars
get_stars(coeffs[i, "Pr(>|t|)"])
)
# Paste all parts of the line together
output_lines <- c(output_lines, paste(line_data, collapse = " "))
}
# Add the footer with the significance codes
output_lines <- c(output_lines, "---")
output_lines <- c(output_lines, "Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1")
# --- 3. Wrap the formatted text in the colored HTML block ---
# Combine all lines into a single string with newline characters
text_collapsed <- paste(output_lines, collapse = "\n")
# Get the color for block 3 from the variable defined in your setup chunk
color <- summary_colors["block3"]
# Create the final HTML string
html_output <- sprintf(
'<div style="background-color: %s; border: 1px solid #ddd; border-radius: 5px; padding: 10px;"><pre style="margin: 0;">%s</pre></div>',
color,
htmltools::htmlEscape(text_collapsed)
)
# Use asis_output to print the raw HTML directly into the document
asis_output(html_output)
}
print_coeffs_with_ci(model_total)
model_partial <- lm(sales ~ TV+radio, data=data_adv)
residuals_partial <- residuals(model_partial)
res_partial<-data.frame(residuals_partial)
summary(res_partial)
#Data.frame
residuals_p <- residuals(model_partial)
res_p<-data.frame(residuals_p)
#Histogram
hist_plot_p <- ggplot(res_p, aes(x = residuals_p)) +
geom_histogram(binwidth = .4, alpha = 0.6, fill = "steelblue") +
labs(title = "Histogram of Residuals",
x = "Value",
y = "Count")
#Density Plot
density_plot_p <- ggplot(res_p, aes(x = residuals_p)) +
geom_density(linewidth = 0.8, fill = "steelblue", alpha = 0.6) +
labs(title = "Density Plot of Residuals",
x = "Value",
y = "Density")
#Box Plot
box_plot_p <- ggplot(res_p, aes(y = residuals_p)) +
geom_boxplot(outlier.colour="red",fill="steelblue") +
labs(title = "Box Plot of Residuals",
x = "",
y = "Value")
#Combine the plots side-by-side using patchwork ---
hist_plot_p + density_plot_p + box_plot_p
summary_with_colors(model_partial)
print_coeffs_with_ci(model_partial)
anova(model_partial,model_total)
{deviance(model_partial)-deviance(model_total)/{3-2}}/{deviance(model_total)/
{200-3-1}}
p_value <- pf(0.03122805, 1, 196, lower.tail = FALSE)
print(p_value)
# Specify which coefficients we want to plot (e.g., the 2nd and 3rd)
params_to_plot <- c(2, 3)
conf_level <- 0.95
# Get the coordinates for the confidence ellipse. This returns a matrix of x and y points that form the ellipse boundary.
ellipse_coords <- ellipse(model_partial, which = params_to_plot, level = conf_level)
# Get the confidence intervals for the individual parameters. These will define the boundaries of our rectangle.
conf_intervals <- confint(model_partial, level = conf_level)
rect_x_bounds <- conf_intervals[params_to_plot[1], ] # CI for the first parameter
rect_y_bounds <- conf_intervals[params_to_plot[2], ] # CI for the second parameter
# Get the point estimate (the center of the ellipse and rectangle)
point_estimate <- coef(model_partial)[params_to_plot]
# Get the names of the coefficients for axis labels
param_names <- names(point_estimate)
# PLOTTING
# First, create an empty plot with the correct dimensions to fit both shapes
plot(0, type = 'n',
xlim = range(ellipse_coords[, 1], rect_x_bounds),
ylim = range(ellipse_coords[, 2], rect_y_bounds),
xlab = paste("Coefficient for", param_names[1]),
ylab = paste("Coefficient for", param_names[2]),
main = "Joint vs. Individual 95% Confidence Regions")
# Add a grid for better readability
grid()
# Draw the confidence rectangle using rect()
# We use a semi-transparent color (via alpha) to allow shapes to be seen through.
rect(xleft = rect_x_bounds[1],
ybottom = rect_y_bounds[1],
xright = rect_x_bounds[2],
ytop = rect_y_bounds[2],
col = rgb(1, 0, 0, alpha = 0.3),  # Semi-transparent red
border = "red")
# Draw the confidence ellipse using polygon()
polygon(ellipse_coords,
col = rgb(0, 0, 1, alpha = 0.3), # Semi-transparent blue
border = "blue")
# Add the dashed lines showing the individual confidence intervals
abline(v = rect_x_bounds, lty = 2, col = "darkred")
abline(h = rect_y_bounds, lty = 2, col = "darkred")
# Add the point estimate (the coefficients) on top
points(point_estimate[1], point_estimate[2],
pch = 19,         # Solid circle
cex = 1.5,        # Make it slightly larger
col = "black")
# Add a legend to explain the colors
legend("topright",
legend = c("Joint Confidence Region (Ellipse)", "Individual CIs (Rectangle)", "Point Estimate"),
fill = c(rgb(0, 0, 1, alpha = 0.3), rgb(1, 0, 0, alpha = 0.3), NA),
border = c("blue", "red", NA),
pch = c(NA, NA, 19),
col = c(NA, NA, "black"),
bty = "n") # No box around the legend
int_conf_partial <- function(new_TV, new_radio, model, conf_level = 0.95) {
# The predict() function requires the new data to be in a data frame.
# The column name ('TV') MUST match the predictor name in the model's formula.
new_data_point <- data.frame(TV = new_TV, radio = new_radio)
# Use predict() to calculate the confidence interval
confidence_interval <- predict(
model,
newdata = new_data_point,
interval = "confidence",
level = conf_level
)
return(confidence_interval)
}
int_conf_partial(new_TV = 350, new_radio = 0, model = model_partial)
int_conf_partial(new_TV = 340, new_radio = 10, model = model_partial)
int_conf_partial(new_TV = 290, new_radio = 60, model = model_partial)
int_conf_partial(new_TV = 280, new_radio = 70, model = model_partial)
int_conf_partial(new_TV = 10, new_radio = 340, model = model_partial)
int_conf_partial(new_TV = 0, new_radio = 350, model = model_partial)
get_confidence_table <- function(new_data, model, conf_level = 0.95) {
# Check if new_data is a data frame
if (!is.data.frame(new_data)) {
stop("Error: 'new_data' must be a data frame.")
}
# Computing the confidence intervals for the mean response for all rows in new_data
confidence_intervals <- predict(
model,
newdata = new_data,
interval = "confidence",
level = conf_level
)
# --- Combine and Return with cbind()
result_table <- cbind(new_data, confidence_intervals)
return(result_table)
}
my_new_points <- data.frame(
TV =    c(350, 340 , 290, 280, 10, 0),
radio = c(0,  10,  60,  70, 340, 350)
)
# Use the new function to get the results in a single table
results_table <- get_confidence_table(new_data = my_new_points, model = model_partial)
# Display the final table
print(results_table)
new_spend <- 350
TV <- c(350, 340 , 290, 280, 10, 0)
radio <- new_spend - TV
my_new_points_s <- data.frame(
TV     ,
radio
)
results_table_s <- get_confidence_table(new_data = my_new_points_s, model=model_partial)
print(results_table_s)
data_partial_sum <- data_adv %>% mutate(partial_sum=TV+radio) %>% select(sales, TV, radio,partial_sum)
summary(data_partial_sum)
int_conf_partial(new_TV = 150, new_radio = 25 , model = model_partial)
new_spend <- 175
TV <- c(140, 145 , 150, 155, 160)
radio <- new_spend - TV
my_new_points_s_n <- data.frame(TV,radio)
results_table_s_n <- get_confidence_table(new_data = my_new_points_s_n, model=model_partial)
print(results_table_s_n)
int_pred_partial <- function(new_TV, new_radio, model, conf_level = 0.95) {
# The predict() function requires the new data to be in a data frame.
# The column name ('TV') MUST match the predictor name in the model's formula.
new_data_point <- data.frame(TV = new_TV, radio = new_radio)
# Use predict() to calculate the confidence interval
prediction_interval <- predict(
model,
newdata = new_data_point,
interval = "prediction",
level = conf_level
)
return(prediction_interval)
}
int_pred_partial(new_TV = 150, new_radio = 25, model = model_partial)
p.values.t <- function(model) {
summary(model)$coefficients[, "Pr(>|t|)"]
}
p.values.t(model_total)
p.values.t(model_partial)
model_list <- list(full_model = model_total, reduced_model = model_partial)
#
extract_pvals_simple <- function(model) {
coef_table <- summary(model)$coefficients
df <- data.frame(
Regressor = rownames(coef_table),
P_Value = coef_table[, "Pr(>|t|)"]
)
rownames(df) <- NULL
return(df)
}
#
final_table <- map_dfr(model_list, extract_pvals_simple, .id = "Model")
#
final_table %>%
# Conditionally format the P-Value column
mutate(P_Value_Formatted = ifelse(P_Value < 0.001,
# If p-value is small, use scientific notation (3 decimal places)
sprintf("%.3e", P_Value),
# Otherwise, round to 4 decimal places
sprintf("%.4f", P_Value))) %>%
#Select the columns
select(Model, Regressor, P_Value_Formatted) %>%
#Call kable on the pre-formatted data
kable(format = "html",
caption = "Model Comparison with P-Values",
# We no longer need the global 'digits' argument
col.names = c("Model", "Regressor", "P-Value")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
row_spec(which(final_table$Model == "full_model"),
background = "#D9E3F4") %>%
row_spec(which(final_table$Model == "reduced_model"),
background = "#F4EAD9")
data_partial_int <- data_adv %>% mutate(int=TV*radio) %>% select(sales, TV, radio,int)
head(data_partial_int)
data_partial_int_1 <- lm(sales ~ TV + radio + int, data=data_partial_int)
print_coeffs_with_ci(data_partial_int_1)
model_partial_int_2 <- lm(sales ~ TV*radio, data = data_adv)
##here, 'TV*radio' is a shorthand for "TV + radio + TV:radio", thus including the first order interaction
print_coeffs_with_ci(model_partial_int_2)
print_coeffs_with_ci(model_partial)
model_full_raw <- lm(sales ~ TV*radio + I(TV^2) + I(radio^2), data = data_adv)
summary_with_colors(model_full_raw)
model_poly_orth <- lm(sales ~ TV:radio + poly(TV, 2) + poly(radio, 2), data = data_adv)
summary_with_colors(model_poly_orth)
# Get the predicted values from both models
predictions_raw <- predict(model_full_raw, newdata = data_adv)
predictions_orth <- predict(model_poly_orth, newdata = data_adv)
# Check if the prediction vectors are numerically equal
all.equal(predictions_raw, predictions_orth)
#> [1] TRUE
# Create a data frame of the predictions for easy plotting
pred_df <- data.frame(
Raw_Predictions = predictions_raw,
Orthogonal_Predictions = predictions_orth
)
# Plot the predictions against each other
plot(
pred_df$Raw_Predictions,
pred_df$Orthogonal_Predictions,
main = "Prediction Comparison: Raw vs. Orthogonal",
xlab = "Predictions from Raw Model",
ylab = "Predictions from Orthogonal Model",
pch = 19,
col = "blue"
)
# Add a perfect y=x line: f points are on this line, they are identical.
abline(a = 0, b = 1, col = "red", lwd = 2)
legend("topleft", legend = "Perfect y=x Line", col = "red", lty = 1, lwd = 2)
print_coeffs_with_ci(model_poly_orth)
# Generate the orthogonal polynomial matrix for TV
poly_tv <- poly(data_adv$TV, 2)
colnames(poly_tv) <- c("TV_poly1", "TV_poly2") # Rename for clarity
# Generate the orthogonal polynomial matrix for radio
poly_radio <- poly(data_adv$radio, 2)
colnames(poly_radio) <- c("radio_poly1", "radio_poly2") # Rename for clarity
# Create a new data frame with these columns
data_adv_poly <- cbind(data_adv, poly_tv, poly_radio)
# Fit the full model using the new, explicit column names
model_poly_manual <- lm(sales ~ TV:radio + TV_poly1 + TV_poly2 + radio_poly1 + radio_poly2,
data = data_adv_poly)
#Checking
summary_with_colors(model_poly_manual)
model_sub <- lm(sales ~ TV:radio + TV_poly1 + TV_poly2 + radio_poly1,
data = data_adv_poly)
summary_with_colors(model_sub)
model_list <- list(full_model = model_poly_manual, reduced_model = model_sub)
#
extract_pvals_simple <- function(model) {
coef_table <- summary(model)$coefficients
df <- data.frame(
Regressor = rownames(coef_table),
P_Value = coef_table[, "Pr(>|t|)"]
)
rownames(df) <- NULL
return(df)
}
#
final_table <- map_dfr(model_list, extract_pvals_simple, .id = "Model")
#
final_table %>%
# Conditionally format the P-Value column
mutate(P_Value_Formatted = ifelse(P_Value < 0.001,
# If p-value is small, use scientific notation (3 decimal places)
sprintf("%.3e", P_Value),
# Otherwise, round to 4 decimal places
sprintf("%.4f", P_Value))) %>%
#Select the columns
select(Model, Regressor, P_Value_Formatted) %>%
#Call kable on the pre-formatted data
kable(format = "html",
caption = "Model Comparison with P-Values",
# We no longer need the global 'digits' argument
col.names = c("Model", "Regressor", "P-Value")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
row_spec(which(final_table$Model == "full_model"),
background = "#D9E3F4") %>%
row_spec(which(final_table$Model == "reduced_model"),
background = "#F4EAD9")
anova(model_sub, model_poly_manual)
anova(model_partial,model_sub)
# Fit the sub-model by replacing poly(radio, 2) with just radio
# Using 'radio' is fine, as a 1st-degree polynomial is just a linear term.
# R will center and scale it appropriately when used inside poly().
model_sub_shortcut <- lm(sales ~ TV:radio + poly(TV, 2) + poly(radio, 1),
data = data_adv)
# View the summary of coefficients
print_coeffs_with_ci(model_sub_shortcut)
# The new function is essentially identical, just renamed for clarity.
# It works because predict() knows how to handle the poly() terms.
int_conf_short <- function(new_TV, new_radio, model, conf_level = 0.95) {
# The predict() function needs the new data in a data frame.
# The column names ('TV', 'radio') MUST match the original variable
# names used inside the poly() and interaction terms in the formula.
new_data_point <- data.frame(TV = new_TV, radio = new_radio)
# Use predict() to calculate the confidence interval.
# R will automatically apply the correct poly() transformations
# and create the interaction term from the 'newdata'.
confidence_interval <- predict(
model,
newdata = new_data_point,
interval = "confidence",
level = conf_level
)
return(confidence_interval)
}
int_conf_short(new_TV = 150, new_radio = 25 , model = model_sub_shortcut)
int_conf_partial(new_TV = 150, new_radio = 25 , model = model_partial)
results_table_quad <- get_confidence_table(new_data = my_new_points, model = model_sub_shortcut)
# Display the final table
print(results_table_quad)
print(results_table_s)
library(tidyverse)
library(ellipse)
library(patchwork)
library(knitr)
library(kableExtra)
library(crayon)
s_partial <- vcov(model_partial) / sigma(model_partial)^2
print(s_partial)
vcov(model_partial)
sigma(model_partial)
vars_of_interest <- c("TV", "radio")
sub_vcov <- [vars_of_interest, vars_of_interest]
cov <- vcov(model_partial)
print(cov)
vars_of_interest <- c("TV", "radio")
sub_vcov <- cov[vars_of_interest, vars_of_interest]
print(sub_vcov)
sigma_sq <- sigma(model)
sigma_sq <- sigma(model_partial)
sigma_sq <- sigma(model_partial)
sigma_sq <- sigma(model_partial)
print(sigma_sq)
sd_model_partial <- sigma(model_partial)
print(sq_model_partial)
sd_model_partial <- sigma(model_partial)
print(sd_model_partial)
s_model_partial <- cov/sd_model_partial^2
s_model_partial <- cov/sd_model_partial^2
vars_of_interest <- c("TV", "radio")
sub_s_model_partial <- s_model_partial[vars_of_interest, vars_of_interest]
print(sub_s_model_partial)
cov <- vcov(model_partial)
print(cov)
vars_of_interest <- c("TV", "radio")
sub_cov <- cov[vars_of_interest, vars_of_interest]
print(sub_cov)
cov <- vcov(model_partial)
cov_matrix <- vcov(model_partial)
print(cov_matrix)
6.12/19.33
6.12/646
theta <- atan2(--6.126744e-07/2,6.464116e-05-1.933089e-06)
theta <- atan2(--6.126744e-07/2,6.464116e-05-1.933089e-06)/2)
theta <- atan2(--6.126744e-07/2,6.464116e-05-1.933089e-06)/2)
theta <- atan2(-6.126744e-07/2,6.464116e-05-1.933089e-06)/2)
theta <- atan2(-6.126744e-07/2,6.464116e-05-1.933089e-06))/2
theta <- atan2(-6.126744*10^-07/2,6.464116*10^-05-1.933089*10^-06))/2
theta <- atan2(-6.126744*10^-07/2,6.464116*10^-05-1.933089*10^-06)/2
print(theta)
theta <- atan2(-2*6.126744*10^-07,6.464116*10^-05-1.933089*10^-06)/2
print(theta)
theta_2 <- atan2(-2*sub_cov_matrix[1,2],sub_cov_matrix[2,2]-sub_cov_matrix[1,2])/2
vars_of_interest <- c("TV", "radio")
sub_cov_matrix <- cov_matrix[vars_of_interest, vars_of_interest]
print(sub_cov_matrix)
theta_2 <- atan2(-2*sub_cov_matrix[1,2],sub_cov_matrix[2,2]-sub_cov_matrix[1,2])/2
print(theta_2)
theta_2 <- atan2(-2*sub_cov_matrix[1,2],sub_cov_matrix[2,2]-sub_cov_matrix[1,1])/2
print(theta_2)
